"""
Agent State Schema for Co-Investigator
Defines the state structure that flows through the LangGraph state machine.

Enhanced with QueryQuest v9.0 features:
- Structured extraction fields (disease_variants, gene_variants, topic_keywords)
- Task history with rollback capability
- Category-based dataset results
"""
from typing import TypedDict, Literal, Annotated, Optional
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import operator
import copy


class TaskStatus(str, Enum):
    """Status of a sub-task in the execution plan."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    SKIPPED = "skipped"
    AWAITING_HITL = "awaiting_hitl"


class DiseaseCategory(str, Enum):
    """Category of disease for research planning."""
    GENETIC = "genetic"
    COMPLEX = "complex"
    NEUROLOGICAL = "neurological"
    CANCER = "cancer"
    INFECTIOUS = "infectious"
    OTHER = "other"


@dataclass
class SubTask:
    """Represents a single sub-task in the research plan."""
    task_id: str
    description: str
    data_source: str  # clingen, civic, reactome, string, openalex, pubmed
    query_type: str   # gene_disease, variant, pathway, interaction, researcher, abstract
    entities: list[str]
    depends_on: list[str] = field(default_factory=list)
    status: TaskStatus = TaskStatus.PENDING
    result: dict | None = None
    error: str | None = None
    started_at: datetime | None = None
    completed_at: datetime | None = None

    def to_dict(self) -> dict:
        """Convert to dictionary for serialization."""
        return {
            "task_id": self.task_id,
            "description": self.description,
            "data_source": self.data_source,
            "query_type": self.query_type,
            "entities": self.entities,
            "depends_on": self.depends_on,
            "status": self.status.value,
            "result": self.result,
            "error": self.error,
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "SubTask":
        """Create from dictionary."""
        return cls(
            task_id=data["task_id"],
            description=data["description"],
            data_source=data["data_source"],
            query_type=data["query_type"],
            entities=data["entities"],
            depends_on=data.get("depends_on", []),
            status=TaskStatus(data.get("status", "pending")),
            result=data.get("result"),
            error=data.get("error"),
            started_at=datetime.fromisoformat(data["started_at"]) if data.get("started_at") else None,
            completed_at=datetime.fromisoformat(data["completed_at"]) if data.get("completed_at") else None,
        )


@dataclass
class TaskHistoryEntry:
    """Single entry in task execution history for rollback support."""
    task_id: str
    action: str  # "started", "completed", "skipped", "rolled_back", "modified"
    timestamp: datetime
    data_snapshot: dict | None = None  # State snapshot for rollback
    reason: str | None = None
    observation: str | None = None

    def to_dict(self) -> dict:
        return {
            "task_id": self.task_id,
            "action": self.action,
            "timestamp": self.timestamp.isoformat(),
            "data_snapshot": self.data_snapshot,
            "reason": self.reason,
            "observation": self.observation,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "TaskHistoryEntry":
        return cls(
            task_id=data["task_id"],
            action=data["action"],
            timestamp=datetime.fromisoformat(data["timestamp"]),
            data_snapshot=data.get("data_snapshot"),
            reason=data.get("reason"),
            observation=data.get("observation"),
        )


@dataclass
class ResearchPlan:
    """
    The overall research plan generated by the planner.

    Enhanced with QueryQuest structured extraction fields.
    """
    research_goal: str
    sub_tasks: list[SubTask]

    # QueryQuest structured extraction fields
    disease_variants: list[str] = field(default_factory=list)  # Full disease names (min 8 chars)
    gene_variants: list[str] = field(default_factory=list)     # Gene symbols if mentioned
    topic_keywords: list[str] = field(default_factory=list)    # Molecular/biological keywords
    researcher_search_query: str = ""                           # Optimized OpenAlex query
    disease_category: str = "other"                             # genetic/complex/neurological/cancer/other

    # Execution control
    hitl_checkpoint_after: str | None = None
    created_at: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> dict:
        """Convert to dictionary for serialization."""
        return {
            "research_goal": self.research_goal,
            "sub_tasks": [t.to_dict() for t in self.sub_tasks],
            "disease_variants": self.disease_variants,
            "gene_variants": self.gene_variants,
            "topic_keywords": self.topic_keywords,
            "researcher_search_query": self.researcher_search_query,
            "disease_category": self.disease_category,
            "hitl_checkpoint_after": self.hitl_checkpoint_after,
            "created_at": self.created_at.isoformat(),
        }

    @classmethod
    def from_dict(cls, data: dict) -> "ResearchPlan":
        """Create from dictionary."""
        return cls(
            research_goal=data["research_goal"],
            sub_tasks=[SubTask.from_dict(t) for t in data["sub_tasks"]],
            disease_variants=data.get("disease_variants", []),
            gene_variants=data.get("gene_variants", []),
            topic_keywords=data.get("topic_keywords", []),
            researcher_search_query=data.get("researcher_search_query", ""),
            disease_category=data.get("disease_category", "other"),
            hitl_checkpoint_after=data.get("hitl_checkpoint_after"),
            created_at=datetime.fromisoformat(data["created_at"]) if data.get("created_at") else datetime.now(),
        )

    def get_primary_disease(self) -> str:
        """Get the primary disease name for queries."""
        return self.disease_variants[0] if self.disease_variants else ""


@dataclass
class ConflictInfo:
    """Information about a detected conflict in the data."""
    conflict_type: str  # contradiction, outdated, low_confidence, missing, quality
    description: str
    affected_entities: list[str]
    recommendation: str

    def to_dict(self) -> dict:
        return {
            "conflict_type": self.conflict_type,
            "description": self.description,
            "affected_entities": self.affected_entities,
            "recommendation": self.recommendation,
        }


@dataclass
class SmartOption:
    """A context-aware HITL option generated by Gemini."""
    label: str           # Short display text
    action: str          # Action identifier (e.g., "narrow_to_definitive")
    impact: str          # Expected outcome description
    modifies_plan: bool = False  # Whether this option modifies the search plan

    def to_dict(self) -> dict:
        return {
            "label": self.label,
            "action": self.action,
            "impact": self.impact,
            "modifies_plan": self.modifies_plan,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "SmartOption":
        return cls(
            label=data["label"],
            action=data["action"],
            impact=data["impact"],
            modifies_plan=data.get("modifies_plan", False),
        )


@dataclass
class HITLCheckpoint:
    """
    Human-in-the-loop checkpoint state.

    Enhanced with SMART adaptive options (context-aware choices).
    """
    checkpoint_id: str
    reason: str
    conflicts: list[ConflictInfo] = field(default_factory=list)

    # Legacy: simple string options
    options: list[str] = field(default_factory=list)

    # NEW: Smart options with context-aware descriptions
    smart_options: list[SmartOption] = field(default_factory=list)

    # Context summary for display
    context_summary: dict = field(default_factory=dict)

    # User response
    user_response: str | None = None
    selected_action: str | None = None
    responded_at: datetime | None = None

    def to_dict(self) -> dict:
        return {
            "checkpoint_id": self.checkpoint_id,
            "reason": self.reason,
            "conflicts": [c.to_dict() for c in self.conflicts],
            "options": self.options,
            "smart_options": [o.to_dict() for o in self.smart_options],
            "context_summary": self.context_summary,
            "user_response": self.user_response,
            "selected_action": self.selected_action,
            "responded_at": self.responded_at.isoformat() if self.responded_at else None,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "HITLCheckpoint":
        return cls(
            checkpoint_id=data["checkpoint_id"],
            reason=data["reason"],
            conflicts=[ConflictInfo(**c) for c in data.get("conflicts", [])],
            options=data.get("options", []),
            smart_options=[SmartOption.from_dict(o) for o in data.get("smart_options", [])],
            context_summary=data.get("context_summary", {}),
            user_response=data.get("user_response"),
            selected_action=data.get("selected_action"),
            responded_at=datetime.fromisoformat(data["responded_at"]) if data.get("responded_at") else None,
        )


def merge_results(existing: dict, new: dict) -> dict:
    """Merge new results into existing results dictionary."""
    merged = existing.copy() if existing else {}
    merged.update(new)
    return merged


class AgentState(TypedDict):
    """
    The main state object that flows through the LangGraph.

    This state is persisted to Firestore at HITL checkpoints
    and restored when the user provides feedback.

    Enhanced with QueryQuest v9.0 features:
    - Structured extraction fields
    - Category-based dataset results
    - Task history with rollback
    """
    # Session identification
    session_id: str

    # User input
    user_query: str

    # Planning
    plan: dict | None  # ResearchPlan as dict
    current_task_index: int

    # QueryQuest structured extraction (copied from plan for easy access)
    disease_variants: list[str]
    gene_variants: list[str]
    topic_keywords: list[str]
    researcher_search_query: str
    disease_category: str

    # Execution results (accumulates across tasks)
    results: Annotated[dict, merge_results]

    # Category-based dataset results (QueryQuest style)
    clingen_results: dict | None      # Gene-disease associations
    pubmedqa_results: dict | None     # Q&A pairs
    biorxiv_results: dict | None      # Preprints
    orkg_results: dict | None         # Knowledge graph triples
    researcher_results: dict | None   # OpenAlex researcher data

    # Conflict detection
    conflicts: list[dict]
    requires_hitl: bool

    # HITL state
    hitl_checkpoint: dict | None  # HITLCheckpoint as dict
    hitl_pending: bool
    human_feedback: str | None

    # Final output
    final_report: str | None
    export_path: str | None  # Path to exported markdown file

    # Execution tracking
    current_node: str
    execution_history: list[str]
    task_history: list[dict]  # TaskHistoryEntry as dicts for rollback
    rollback_points: list[dict]  # State snapshots for rollback
    error: str | None

    # Timestamps
    started_at: str
    updated_at: str


def create_initial_state(session_id: str, user_query: str) -> AgentState:
    """Create a new initial agent state."""
    now = datetime.now().isoformat()
    return AgentState(
        session_id=session_id,
        user_query=user_query,
        plan=None,
        current_task_index=0,
        # Structured extraction (populated by planner)
        disease_variants=[],
        gene_variants=[],
        topic_keywords=[],
        researcher_search_query="",
        disease_category="other",
        # Results
        results={},
        clingen_results=None,
        pubmedqa_results=None,
        biorxiv_results=None,
        orkg_results=None,
        researcher_results=None,
        # Conflicts
        conflicts=[],
        requires_hitl=False,
        # HITL
        hitl_checkpoint=None,
        hitl_pending=False,
        human_feedback=None,
        # Output
        final_report=None,
        export_path=None,
        # Tracking
        current_node="start",
        execution_history=["start"],
        task_history=[],
        rollback_points=[],
        error=None,
        # Timestamps
        started_at=now,
        updated_at=now,
    )


def create_rollback_point(state: AgentState, reason: str) -> dict:
    """Create a rollback point from the current state."""
    return {
        "timestamp": datetime.now().isoformat(),
        "reason": reason,
        "current_task_index": state["current_task_index"],
        "results_snapshot": copy.deepcopy(state["results"]),
        "plan_snapshot": copy.deepcopy(state["plan"]),
    }


def add_task_history(
    state: AgentState,
    task_id: str,
    action: str,
    reason: str | None = None,
    observation: str | None = None,
) -> list[dict]:
    """Add an entry to the task history."""
    entry = TaskHistoryEntry(
        task_id=task_id,
        action=action,
        timestamp=datetime.now(),
        reason=reason,
        observation=observation,
    )
    history = state.get("task_history", []).copy()
    history.append(entry.to_dict())
    return history

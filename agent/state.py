"""
Agent State Schema for Co-Investigator
Defines the state structure that flows through the LangGraph state machine.
"""
from typing import TypedDict, Literal, Annotated
from dataclasses import dataclass, field
from datetime import datetime
from enum import Enum
import operator


class TaskStatus(str, Enum):
    """Status of a sub-task in the execution plan."""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    AWAITING_HITL = "awaiting_hitl"


@dataclass
class SubTask:
    """Represents a single sub-task in the research plan."""
    task_id: str
    description: str
    data_source: str  # clingen, civic, reactome, string, openalex, pubmed
    query_type: str   # gene_disease, variant, pathway, interaction, researcher, abstract
    entities: list[str]
    depends_on: list[str] = field(default_factory=list)
    status: TaskStatus = TaskStatus.PENDING
    result: dict | None = None
    error: str | None = None
    started_at: datetime | None = None
    completed_at: datetime | None = None

    def to_dict(self) -> dict:
        """Convert to dictionary for serialization."""
        return {
            "task_id": self.task_id,
            "description": self.description,
            "data_source": self.data_source,
            "query_type": self.query_type,
            "entities": self.entities,
            "depends_on": self.depends_on,
            "status": self.status.value,
            "result": self.result,
            "error": self.error,
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
        }

    @classmethod
    def from_dict(cls, data: dict) -> "SubTask":
        """Create from dictionary."""
        return cls(
            task_id=data["task_id"],
            description=data["description"],
            data_source=data["data_source"],
            query_type=data["query_type"],
            entities=data["entities"],
            depends_on=data.get("depends_on", []),
            status=TaskStatus(data.get("status", "pending")),
            result=data.get("result"),
            error=data.get("error"),
            started_at=datetime.fromisoformat(data["started_at"]) if data.get("started_at") else None,
            completed_at=datetime.fromisoformat(data["completed_at"]) if data.get("completed_at") else None,
        )


@dataclass
class ResearchPlan:
    """The overall research plan generated by the planner."""
    research_goal: str
    sub_tasks: list[SubTask]
    hitl_checkpoint_after: str | None = None
    created_at: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> dict:
        """Convert to dictionary for serialization."""
        return {
            "research_goal": self.research_goal,
            "sub_tasks": [t.to_dict() for t in self.sub_tasks],
            "hitl_checkpoint_after": self.hitl_checkpoint_after,
            "created_at": self.created_at.isoformat(),
        }

    @classmethod
    def from_dict(cls, data: dict) -> "ResearchPlan":
        """Create from dictionary."""
        return cls(
            research_goal=data["research_goal"],
            sub_tasks=[SubTask.from_dict(t) for t in data["sub_tasks"]],
            hitl_checkpoint_after=data.get("hitl_checkpoint_after"),
            created_at=datetime.fromisoformat(data["created_at"]) if data.get("created_at") else datetime.now(),
        )


@dataclass
class ConflictInfo:
    """Information about a detected conflict in the data."""
    conflict_type: str  # contradiction, outdated, low_confidence, missing, quality
    description: str
    affected_entities: list[str]
    recommendation: str

    def to_dict(self) -> dict:
        return {
            "conflict_type": self.conflict_type,
            "description": self.description,
            "affected_entities": self.affected_entities,
            "recommendation": self.recommendation,
        }


@dataclass
class HITLCheckpoint:
    """Human-in-the-loop checkpoint state."""
    checkpoint_id: str
    reason: str
    conflicts: list[ConflictInfo] = field(default_factory=list)
    options: list[str] = field(default_factory=list)
    user_response: str | None = None
    responded_at: datetime | None = None

    def to_dict(self) -> dict:
        return {
            "checkpoint_id": self.checkpoint_id,
            "reason": self.reason,
            "conflicts": [c.to_dict() for c in self.conflicts],
            "options": self.options,
            "user_response": self.user_response,
            "responded_at": self.responded_at.isoformat() if self.responded_at else None,
        }


def merge_results(existing: dict, new: dict) -> dict:
    """Merge new results into existing results dictionary."""
    merged = existing.copy() if existing else {}
    merged.update(new)
    return merged


class AgentState(TypedDict):
    """
    The main state object that flows through the LangGraph.

    This state is persisted to Firestore at HITL checkpoints
    and restored when the user provides feedback.
    """
    # Session identification
    session_id: str

    # User input
    user_query: str

    # Planning
    plan: dict | None  # ResearchPlan as dict
    current_task_index: int

    # Execution results (accumulates across tasks)
    results: Annotated[dict, merge_results]

    # Conflict detection
    conflicts: list[dict]
    requires_hitl: bool

    # HITL state
    hitl_checkpoint: dict | None  # HITLCheckpoint as dict
    hitl_pending: bool
    human_feedback: str | None

    # Final output
    final_report: str | None

    # Execution tracking
    current_node: str
    execution_history: list[str]
    error: str | None

    # Timestamps
    started_at: str
    updated_at: str


def create_initial_state(session_id: str, user_query: str) -> AgentState:
    """Create a new initial agent state."""
    now = datetime.now().isoformat()
    return AgentState(
        session_id=session_id,
        user_query=user_query,
        plan=None,
        current_task_index=0,
        results={},
        conflicts=[],
        requires_hitl=False,
        hitl_checkpoint=None,
        hitl_pending=False,
        human_feedback=None,
        final_report=None,
        current_node="start",
        execution_history=["start"],
        error=None,
        started_at=now,
        updated_at=now,
    )
